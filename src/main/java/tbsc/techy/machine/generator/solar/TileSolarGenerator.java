/*
 * Copyright Â© 2016 Tbsc
 *
 * Techy is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * Techy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with Techy.  If not, see <http://www.gnu.org/licenses/>.
 */

package tbsc.techy.machine.generator.solar;

import net.minecraft.item.ItemStack;
import tbsc.techy.api.util.PositionUtil;
import tbsc.techy.init.BlockInit;
import tbsc.techy.machine.generator.TileGeneratorBase;

import javax.annotation.Nonnull;

/**
 * Tile entity for the solar generator.
 *
 * Created by tbsc on 6/13/16.
 */
public class TileSolarGenerator extends TileGeneratorBase {

    public TileSolarGenerator() {
        super(100000, 200, BlockInit.blockSolarGenerator.tileInvSize, 0, 1);
    }

    @Override
    public void update() {
        if (handleRedstone() || handleBoosters() || handleProcessing() || handleExtraction()) {
            markDirty();
        }
    }

    /**
     * I need to reimplement this method because the way the base tile does it is by consuming the input
     * stack, which I don't have because solar generators generate based on condition. The condition is
     * when it is day and if the block is exposed to the sky directly
     * @return should mark dirty
     */
    @Override
    protected boolean handleProcessing() {
        boolean markDirty = false;

        if (shouldOperate()) {
            if (canOperate()) { // day time and correct height
                if (!worldObj.getBlockState(pos).getValue(BlockSolarGenerator.WORKING)) {
                    worldObj.setBlockState(pos, worldObj.getBlockState(pos).withProperty(BlockSolarGenerator.WORKING, true));
                }
                if (!isRunning) {
                    setOperationStatus(true);
                }
                energyStorage.setEnergyStored(getEnergyStored() + calculateGeneratedEnergy());
                markDirty = true;
            } else {
                if (isRunning) {
                    setOperationStatus(false);
                }
                if (worldObj.getBlockState(pos).getValue(BlockSolarGenerator.WORKING)) {
                    worldObj.setBlockState(pos, worldObj.getBlockState(pos).withProperty(BlockSolarGenerator.WORKING, false));
                }
            }
        } else {
            if (isRunning) {
                setOperationStatus(false);
            }
            if (worldObj.getBlockState(pos).getValue(BlockSolarGenerator.WORKING)) {
                worldObj.setBlockState(pos, worldObj.getBlockState(pos).withProperty(BlockSolarGenerator.WORKING, false));
            }
        }

        return markDirty;
    }

    @Nonnull
    @Override
    public int[] getEnergySlots() {
        return new int[0];
    }

    @Nonnull
    @Override
    public int[] getInputSlots() {
        return new int[0];
    }

    @Nonnull
    @Override
    public int[] getOutputSlots() {
        return new int[0];
    }

    @Nonnull
    @Override
    public int[] getBoosterSlots() {
        return new int[] {
                0, 1, 2, 3
        };
    }

    /**
     * Checks if in the world the solar generator is in it's daytime, and if the block is directly under the sky
     * @return can the generator operate
     */
    @Override
    public boolean canOperate() {
        return 0 <= worldObj.getWorldTime() && worldObj.getWorldTime() < 13000 // Make sure it's day
                && PositionUtil.isBlockHighest(worldObj, pos) // Make sure it's exposed to sky
                && !worldObj.isRainingAt(pos); // Make sure it's not raining
    }

    /**
     * Calculates the amount of energy that can be generated, relative to the current time.
     * Generally speaking, it takes the distance in ticks from mid day, then subtracts the energy
     * to be generated by a fraction of the distance.
     * @return amount of energy generated
     */
    private int calculateGeneratedEnergy() {
        if (worldObj.getWorldTime() > 6000) { // past mid-day
            int energy = (int) (13001 - worldObj.getWorldTime()); // calculates amount of rf generated by time
            energy = energy / 5;
            return energy;
        } else {
            int energy = (int) worldObj.getWorldTime();
            energy = energy / 5;
            return energy;
        }
    }

    /**
     * No item generation, so false
     * @param item if energy can be generated from this
     * @return false
     */
    @Override
    public boolean canGenerateFromItem(ItemStack item) {
        return false;
    }

    /**
     * No item generation, so 0
     * @param item to check
     * @return 0
     */
    @Override
    protected int getBurnTimeFromItem(ItemStack item) {
        return 0;
    }

    /**
     * No item generation, so 0
     * @param input generation input
     * @return 0
     */
    @Override
    public int getEnergyUsage(ItemStack input) {
        return 0;
    }

    @Override
    public String getName() {
        return BlockInit.blockSolarGenerator.getLocalizedName();
    }

}
